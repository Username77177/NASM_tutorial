# 3. Подсчёт длины строки

Зачем нам нужно вычислять длину строки?
Что ж, sys_write требует, чтобы мы передали ему указатель на строку, которую мы хотим вывести на экран, и длину
в байтах, чтобы знать от какого значения считать (первый аргумент) и до какого значения (второй аргумент). Если бы мы изменили нашу строку сообщения, нам пришлось бы обновить длину в байтах
которую мы передаем sys_write, иначе она не будет печататься правильно.

Можно изменить строку, используя программу в уроке_2. Измените строку сообщения, чтобы сказать «Привет, храбрый новый мир!»,
затем скомпилируйте, скомпонуйте и запустите новую программу. Вывод будет "Привет, храбры" (первые 14 символов), потому что
мы по-прежнему передаем sys_write только 14 байтов в качестве его длины. Навык будет будет особенно необходим, когда мы хотим
распечатать пользовательский ввод. Поскольку мы не будем знать длину данных при компиляции нашей программы, нам потребуется способ
рассчитать длину во время выполнения, чтобы успешно распечатать его.

Чтобы вычислить длину строки, мы будем использовать метод, называемый арифметикой указателей. Два регистра ссылаются на один указатель в памяти. Один регистр (в данном случае EAX) будет увеличен вперед
один байт для каждого символа в выходной строке, пока мы не достигнем конца строки. Затем вычтем из *EAX(адрес конца строки)* *EBX(адрес начала строки)*, это фактически как вычитание между двумя массивами, и результат дает количество элементов между двумя адресами. Этот результат затем передается в sys_write (в регистр EDX).

Инструкция CMP сравнивает левую и правую части и флаг, который используется для выполнения программы. Флаг, который мы проверяем, это ZF или «Нулевой флаг». Когда байт, на который указывает EAX
равен нулю, установлен флаг ZF. Мы используем инструкцию JZ для перехода, если установлен флаг ZF, к точке в нашей программе с надписью «finished». После этого мы должны выйти из цикла nextchar и продолжить выполнение остальной части программы.

Следует заранее пояснить, что метка задается `имя:`
**Метка** - не более чем имя для ячейки памяти, в которой лежит какая-то строка

```assembly
SECTION .data
msg	db	"Hello, brave new world!", 0Ah
;Мы можем изменять строку, и не изменять ничего больше в программе
 
SECTION .text
global  _start
 
_start:
 mov	ebx, msg
;Перемещаем адрес нашего сообщения в EBX

mov	eax, ebx
;Перемещаем EAX в EBX (Оба указывают на один и тот же сегмент в коде)
 ;EBX независим от EAX, если EAX изменяется, то EBX не будет
  ;с момента передачи в него данных
  
nextchar:
cmp	byte [eax], 0	
;Сравнить байт по адресу EAX с 0
			;(Нуль всегда конец строки)
      
jz finished
;Перепрыгнуть к finished, если сравнение дало 0 (jump if zero "jz")
; Если выполнение никуда не прыгнет, то выполнятся следующие строки:

inc	eax	
;Увеличить EAX на 1 байт (каждая ячейка памяти 8 бит)

jmp	nextchar
;Прыгнуть на nextchar (в любом случае)
 
finished:
 sub	eax, ebx  ;Отнять от EAX EBX (EAX = EAX - EBX)
;Результатом является число байт между ячейкой EAX и EBX
 
 mov	edx, eax	;Длина строки в EDX
 mov	ecx, msg	;Остальное уже вам знакомо
 mov	ebx, 1
 mov	eax, 4
 int 80h

 mov	ebx, 0
 mov	eax, 1
 int 80h```