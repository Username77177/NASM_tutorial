# 1. Hello World

``В данном уроке мы выведем Hello World на языке NASM``

## Язык ассемблера. 

Единственный интерфейс, который программист имеет над реальным оборудованием, - это само ядро. Для написания программ нам нужно использовать **системные вызовы Linux (Windows)**, предоставляемые ядром. Эти системные вызовы представляют собой библиотеку (набор функций), встроенную в операционную систему для обеспечения таких функций, как *чтение ввода с клавиатуры* и *запись вывода на экран*, а также многое другое.

Когда вы вызываете **системный вызов**, ядро немедленно приостанавливает выполнение вашей программы. Затем он свяжется с необходимыми драйверами, необходимыми для выполнения запрошенной вами задачи на оборудовании, а затем вернет управление обратно в вашу программу.

Мы можем выполнить все основные действия (чтение, вывод), *загрузив в EAX число, которое определяет, что мы хотим сделать* (это ещё называется код операции или *OPCODE*), который мы хотим выполнить, и заполнив оставшиеся регистры аргументами, которые мы хотим передать системному вызову. Программное прерывание запрашивается инструкцией INT, после запроса ядро само управляет данными и вызывает функцию из библиотеки с нашими аргументами. Это если объяснять доходчиво.

[Таблица с такими кодами](https://syscalls.kernelgrok.com/)

Простейшими кодами вызова являются **sys_write** и **sys_exit**
Для того, чтобы вывести что-то на экран нужно передать значение 4 в eax, 1 в bx, само сообщение в cx, длину сообщения в dx

Разберём первый пример:

```assembly
SECTION .data ; объяснение секций будет ниже
msg db 'Hello World!', 0Ah
;инициализируем переменную msg задаём ей значение "Hello World"
;0Ah - символ новой строки (в десятичной - 10)
 
SECTION .text 
global  _start ;метка для линкера
;тоже самое что и int main() в C++
 
_start: ; начало работы программы
    mov eax, 4      
;Вызываем sys_write, помещая 4 в EAX

    mov ebx, 1
;Помещая 1 в EBX, мы говорим что хотим стандартный вывод (на экран)

    mov ecx, msg
;Перемещаем адрес, по которому хранится строка в ECX
    
    mov edx, 13
;Перемещаем длину строки + 1 (символ новой строки) в EDX
    int 80h
    ;Вызываем системное прерывание с помощью int 80h
    ;(128 - в десятиричной)
```

Как вы уже могли заметить, регистр в ассемблере не играет значения
NASM все равно напишете вы **EAX** или **eax**

Секции - это блоки кода специального назначения.
В NASM 3 секции:

* .data
* .bss
* .text

**.data** - нужна для объявления статических переменных, размер которых не будет изменяться. Эта секция хорошо подходит для констант
**.bss** - секция для резервирования места для переменных. Хорошо подходит для динамических переменных
**.data** - секция для кода программы

## Линкер и этапы создания программы

Линкер нужен для соединения множества программ на NASM.
```assembly
global _start
```
Объявляется глобальной **меткой** (метка - названный адрес памяти, для удобства, если по простому, то это просто ссылка, на какую строку программы нужно перейти). Глобальной  **_start** объявляется именно для *линкера*

Линкер также называют сборщиком, собирателем ит.д.

Для того, чтобы скомпилировать программу на NASM следует ввести следующее с консоль (*Linux*):

```bash
nasm -f elf имя_файла.asm
ld -m elf_i386 имя_файла.o -o имя_исполняемого_файла
```
**Имя исполняемого файла может быть каким угодно, также как и исходного (с кодом)**

*nasm* - компилятор

*ld* - линкер
